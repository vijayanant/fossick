
# Microservice Architecture with Docker

Microservice architecture is a good solution for companies trying to maximize their resources, both human and machine, to develop clean, maintainable, scalable, available code. In order to take advantage of this architecture, we must first comprehend it, and then learn how to master it. Microservice Architecture is a solid, modern architecture and Docker is the best way to get started with this architecture.

## Microservice Architecture

Microservice Architecture is a modern architecture designed explicitly for independence, scalability, and reliability through system failure. In their definitive expose on microservices [[1]](#1), James Lewis and Martin Fowler describe the “common characteristics” that such an architecture should possess. They define microservices to be a style of architecture for “developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API” [[1]](#1). This single sentence definition is fairly succinct: Microservices are just miniature services that make up an application. However, the power of the microservice architecture is found in the specific way these services are connected and how they are separated.

### The Key Features of Microservice Architecture

The first key feature that a microservice architecture provides is interoperability. Because each microservice communicates with a high-level API such as HTTP, instead of something lower level like Java's RMI, the service is completely independent. Designers of these individual services are free to make their own lower-level decisions, from the programming language used to write the service to the physical hardware running the service. A Raspberry Pi could take part in a microservice architecture with a large cloud cluster because the HTTP-based API could allow communication between these two disparate platforms.

The second powerful feature of microservice architecture is the way services are segregated. A major decision any architecture faces is how to divide up responsibilities—which components will be responsible for which requirements. Lewis and Fowler remark that when management break down application requirements for individual teams, they tend to break them up via technology (e.g.: UI, database, security, etc) [[1]](#1). They further suggest that such an architecture will inevitably follow Conway's Law, which says, “Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.” This might be convenient for short-term applications, but it is less ideal in the long-term—and most software teams want their applications to work in the long term. Instead of separating responsibilities by technical necessity, the microservice architecture divides services by their “business capability” [[1]](#1). This results in team independence, e.g.: the UI team no longer depends upon another team to design and implement the database for their application. A team must be full-stack, and, as a result, will have much more autonomy in making design and implementation decisions.

### Benefits of Microservice Architecture

Clearly, the main theme of microservice architecture is independence. The benefits of design and implementation independence are numerous.

The first benefit has already been mentioned: Teams responsible for their own full-stack processes are free to choose implementation tools, libraries, and languages<sup>[1](#footnote-1)</sup> that they want and the final products can be distributed across many types of physical hardware, including cloud computing resources.

Secondly, the coupling between modules is reduced drastically. Since services must communicate between each other by a high-level API, they do not have build-time dependencies on each other. As long as the API evolution doesn't result in breaking changes, the service can continue to be improved with new functionality and receive maintenance without ever interfering with other services.

Another benefit of microservices, which is also a necessity due to structure, is decentralized data. In a monolithic architecture, it is not uncommon for all application data to reside in a single database. In the microservice style, each service has its own data store, and these data stores are very rarely shared. With the rise in understanding and popularity of NoSQL, this segregation of data allows individual services to store their data using a tool that best fits their data, whether it be SQL, NoSQL, or something different entirely, like Elasticsearch.

Yet another benefit of this style of architecture is that it can be designed for failure. To clarify, I will use the example of Chaos Monkey developed by Netflix. In 2015, Time magazine reported that 37% of North American internet traffic “during peak evening hours” consisted of Netflix streaming video [[2]](#2). Because the demand for Netflix video is so great and because the content Netflix distributes must allow users to engage in real-time, Netflix must have a very reliable, low latency system. To meet this need, Netflix relies on Amazon's AWS  cloud computing platform. While AWS can provide the scalability and distributed replications, Netflix's applications must still be designed to work together in such an environment. Netflix's concern in this scenario is that a single service failure could bring down their network. Netflix says that their “best defense against major unexpected failures is to fail often. By frequently causing failures, we force our services to be built in a way that is more resilient” [[3]](#3). And Netflix does cause failures—literally. The Chaos Monkey tool's task is to randomly select a running service and to terminate it. Chaos Monkey terminates small parts at a time so that no customers will be impacted, but if the system were not designed to continue working through these intentional failures, the system would quickly be brought to its knees. Since the whole is a sum of its parts, each service must be able to compensate for the failures of other services, as well as accept new services that have been spun up to take the place of those which were defective.

### Alternatives to Microservice Architecture

As we can see, microservice architecture brings about very positive characteristics in the systems which follow this pattern. Microservices are perceived as a step forward in the domain of software architecture, but it is worth considering what architectural styles and their relevant benefits a transition to a microservice architecture might abandon.

Microservice architecture falls under the umbrella of Service-Oriented Architecture (SOA). Some equate the two, claiming that “Microservice” is just a buzzword invented to describe a preexisting architectural pattern. Lewis and Fowler in [[1]](#1) say this isn't too far from the mark, but that SOA can also imply the use of a design structure called the Enterprise Service Bus (ESB), or as Jim Webber has referred to it, the “Egregious Spaghetti Box” [[4]](#4). While the ESB pattern was originally designed to be much closer to the microservice pattern we see today, vendors began selling hub-and-spoke Enterprise Application Integration middleware as ESB and, according to Matt McLarty from InfoWorld, “customers ate them up” [[[5]](#5). The resulting structure more closely resembled that of monolithic architecture.

Monolithic architecture might sound old and unusable, but monolithic architecture has its place. Monoliths produce an executable output that is designed to run together on a single physical or virtual machine. A monolithic style is acceptable when the application is small and the solution is evident. In fact, monolithic architecture is often a preferable pattern to follow when designing a new system. Fowler contends in [[6]](#6) that successful microservice architectures have grown out of a monolith, and that those projects which began as a pure microservices tend to fall apart. Microservices require a component separation based around business value, and since business value of components is shaped by customers, it is easy to get the separation of responsibilities wrong. Fowler reasons that the cost of using microservices from the start of a project is often too great—that the cost of trying to maintain a set of microservices will inhibit progress. Instead, he says teams should consider a “monolith-first strategy, where you should build a new application as a monolith initially, even if you think it's likely that it will benefit from a microservices architecture” [[6]](#6). Fowler outlines a couple variations on the monolith-first strategy when moving from a monolith to microservices: design the monolith with components in mind and then refactor components out. Use Strangler Pattern to “peel off” components and implement new components as microservices, or completely discard the monolith and re-write the microservices from scratch (the benefit here is that the original monolith design does not have to care about a later refactoring and can help a company be first to market).

Monolithic architecture can be used as a stepping stone to microservices, but it is often incorrectly thought of as the only alternative to a microservice architecture. Often, any style of architecture that does not follow the microservice pattern is called a monolith, and this is a misconception. As an alternative to both monolithic and microservice architectures, it is possible to use a cookie-cutter architecture pattern as documented by Paul Hammant in [[7]](#7). Instead of scaling each service independently, it is possible to instead scale the entire system at once, replicating the processes again and again to machines as demand increases. It is also possible to design components that interact over a common language specific interface (as opposed to HTTP) inside of a single process and then scale that process to many machines. Neither of these variations of SOA are true microservices or monoliths because they are independently built processes or services (not a monolith), but they are not independently scaled or deployed (not a microservice). Cookie-cutter architecture can be easier to use and understand, so it can be used as an alternative to both microservices and monoliths. For a depiction of how monoliths differ from microservices, see Figure 1.

![Figure 1: Difference between dow Monoliths and Microservices scale [1]](https://martinfowler.com/articles/microservices/images/sketch.png)
_Figure 1: Difference between how Monoliths and Microservices scale [[1]](#1)_

### Microservice Architecture Criticism

Though microservices have many benefits and the alternatives seem like inferior solutions, there are still some drawbacks to adopting the microservice architecture.
First, there is some duplication of effort. Benjamin Wootton, CTO of Contino, points out in [[8]](#8) that changing requirements which span services are difficult to implement. A new service could be created to fulfill the system-wide change, but that would introduce synchronous coupling<sup>[2](#footnote-2)</sup> which is undesirable. A common library could be used between the running services to avoid this coupling, but since microservices often polyglot, this solution is often not possible. The only remaining solution that would not result in synchronous coupling could result in duplicating the work between services. This is not a problem with monolithic applications.

Next is the issue of testability and asynchronicity. Unlike monoliths and some SOA pattern designs, microservices communicate using primarily asynchronous calls. This results in a more complicated system, especially in the area of testing when needing to test a service which relies on other services because it is hard to mock the production environment. Wootton says that instead of placing a large emphasis on testing, developers focus on monitoring their services in production to find problems and ensure correctness [[8]](#8). Eugene Dvorkin points out in [[9]](#9) that monitoring itself can be a difficult problem for a distributed system; it can be hard to aggregate metrics and error logs on running services. Fortunately, Dvorkin provides an answer to these problems, telling his readers to use prebuilt solutions like Logstash and Riemann.

However, the largest drawback, by far, is the complexity of microservices and the cost of operations as a direct result. Microservice architecture requires skilled DevOps and System Networking teams to deploy the very complex final product that such an architectural style produces. Because of its polyglot nature, the process is only complicated further. Wootton says the operations team must be “embedded within your development team” as developers are constructing a full-stack service using whichever tools they desire [[8]](#8). The deployment, monitoring, and provisioning hardware for all the services also add up and can make the entire development process slower [[9]](#9). This is the caveat of the microservice architecture: sure, it is possible to build a great distributed system, but developers must have the know-how and the tooling to maintain it. A key tool used by most successful adopters of the microservice architecture to bring their projects to life is the Linux container.
